#include <Adafruit_CircuitPlayground.h>
#include <bluefruit.h>
#include <math.h>

/********* Config runtime (ajustables por BLE) *********/
float targetDeg   = 30.0f;     // THR <deg>
float deadzoneDeg = 10.0f;     // DEAD <deg>
float emaAlpha    = 0.15f;     // EMA <0..1>
uint16_t reportMs = 250;       // REPORT <ms>
uint16_t pulseMs  = 800;       // PULSE <ms> motor

/********* Pines *********/
const int MOTOR_PIN = A1;      

/********* BLE *********/
BLEUart bleuart;

/********* Estado *********/
float  zeroOffsetDeg = 0.0f;
float  emaDeg        = 0.0f;
bool   goalLatched   = false;
bool   motorOn       = false;
uint32_t lastTx      = 0;
uint32_t motorOffAt  = 0;
uint32_t btnADownAt  = 0;

/********* Utils *********/
static inline float clampf(float v, float lo, float hi) {
  return (v < lo) ? lo : (v > hi ? hi : v);
}

void setRing(uint8_t r, uint8_t g, uint8_t b) {
  for (int i = 0; i < 10; i++) CircuitPlayground.setPixelColor(i, r, g, b);
}

void setRingProgress(float aAbs, float thr) {
  // aAbs en [0, 90], thr = targetDeg
  float ratio = clampf(aAbs / thr, 0.0f, 1.0f);
  int lit = (int)roundf(ratio * 10.0f);
  uint8_t r=255, g=0, b=0;
  if (aAbs < deadzoneDeg) { r=255; g=0;   b=0;   }        // rojo
  else if (aAbs < thr)    { r=255; g=210; b=0;   }        // amarillo
  else                    { r=0;   g=255; b=0;   }        // verde

  for (int i=0;i<10;i++) {
    if (i < lit) CircuitPlayground.setPixelColor(i, r, g, b);
    else         CircuitPlayground.setPixelColor(i, 10, 10, 15); // tenue
  }
}

float rawAngleDeg() {
  float x = CircuitPlayground.motionX();
  float y = CircuitPlayground.motionY();
  float z = CircuitPlayground.motionZ();
  float ang = atan2f(x, sqrtf(y*y + z*z)) * 180.0f / PI;  // [-90..90]
  return clampf(ang, -90.0f, 90.0f);
}

float measureAngleDeg() {
  float ang = rawAngleDeg();
  emaDeg = (1.0f - emaAlpha)*emaDeg + emaAlpha*ang;
  float out = emaDeg - zeroOffsetDeg;
  return clampf(out, -90.0f, 90.0f);
}

void startAdv() {
  Bluefruit.Advertising.stop();
  Bluefruit.Advertising.addFlags(BLE_GAP_ADV_FLAGS_LE_ONLY_GENERAL_DISC_MODE);
  Bluefruit.Advertising.addTxPower();
  Bluefruit.Advertising.addService(bleuart);
  Bluefruit.ScanResponse.addName();
  Bluefruit.Advertising.restartOnDisconnect(true);
  Bluefruit.Advertising.setInterval(32, 244);
  Bluefruit.Advertising.setFastTimeout(30);
  Bluefruit.Advertising.start(0);
}

void motorPulse(uint16_t ms) {
  digitalWrite(MOTOR_PIN, HIGH);
  motorOn   = true;
  motorOffAt = millis() + ms;
}

/********* Comandos BLE (sin String) *********/
char rxbuf[64];  // línea
size_t rxlen = 0;

void handleCommand(const char* line) {
  // Formatos:
  //  RESET
  //  THR <deg>
  //  DEAD <deg>
  //  EMA <0..1>
  //  REPORT <ms>
  //  PULSE <ms>
  //  NAME <text>
  //  PING
  //  STATUS
  if (strcasecmp(line, "RESET") == 0) {
    goalLatched = false;
    bleuart.println("OK RESET");
    return;
  }
  if (strcasecmp(line, "PING") == 0) {
    bleuart.println("PONG");
    return;
  }
  if (strcasecmp(line, "STATUS") == 0) {
    char js[96];
    snprintf(js, sizeof(js),
      "{\"angle\":%.1f,\"thr\":%.1f,\"dead\":%.1f,\"ema\":%.2f}\n",
      emaDeg - zeroOffsetDeg, targetDeg, deadzoneDeg, emaAlpha);
    bleuart.print(js);
    return;
  }

  // con argumento
  char cmd[8]; float valf = 0; int vali = 0;
  if (sscanf(line, "%7s %f", cmd, &valf) == 2) {
    if (strcasecmp(cmd, "THR") == 0 && valf>5 && valf<=80) {
      targetDeg = valf; bleuart.print("OK THR "); bleuart.println(targetDeg,1); return;
    }
    if (strcasecmp(cmd, "DEAD") == 0 && valf>=0 && valf<targetDeg) {
      deadzoneDeg = valf; bleuart.print("OK DEAD "); bleuart.println(deadzoneDeg,1); return;
    }
    if (strcasecmp(cmd, "EMA") == 0 && valf>=0.01f && valf<=0.9f) {
      emaAlpha = valf; bleuart.print("OK EMA "); bleuart.println(emaAlpha,2); return;
    }
    if (strcasecmp(cmd, "REPORT") == 0 && valf>=50 && valf<=2000) {
      reportMs = (uint16_t)valf; bleuart.print("OK REPORT "); bleuart.println(reportMs); return;
    }
    if (strcasecmp(cmd, "PULSE") == 0 && valf>=100 && valf<=3000) {
      pulseMs = (uint16_t)valf; bleuart.print("OK PULSE "); bleuart.println(pulseMs); return;
    }
  } else if (sscanf(line, "NAME %63[^\n]", cmd) == 1) {
    Bluefruit.setName(cmd);
    bleuart.print("OK NAME "); bleuart.println(cmd);
    startAdv(); // reinicia advertising con el nuevo nombre
    return;
  }

  bleuart.println("ERR");
}

void readBleCommands() {
  while (bleuart.available()) {
    char c = (char)bleuart.read();
    if (c == '\r') continue;
    if (c == '\n') {
      rxbuf[rxlen] = 0;
      if (rxlen) handleCommand(rxbuf);
      rxlen = 0;
    } else if (rxlen < sizeof(rxbuf)-1) {
      rxbuf[rxlen++] = c;
    }
  }
}

/********* Setup *********/
void setup() {
  CircuitPlayground.begin();
  pinMode(MOTOR_PIN, OUTPUT);
  digitalWrite(MOTOR_PIN, LOW);
  setRing(0,0,0);

  Bluefruit.begin();
  Bluefruit.setName("VibeTurn-CPB");
  bleuart.begin();
  startAdv();
}

/********* Loop *********/
void loop() {
  // --- Calibración por long-press botón A ---
  bool btnA = CircuitPlayground.leftButton();
  if (btnA && btnADownAt==0) btnADownAt = millis();
  if (!btnA && btnADownAt>0) btnADownAt = 0;
  if (btnA && (millis()-btnADownAt) > 600) {
    zeroOffsetDeg = rawAngleDeg(); // referencia actual
    goalLatched   = false;
    btnADownAt    = millis(); // evita recalibrar cada ciclo
    // flash azul corto
    for (int i=0;i<10;i++) CircuitPlayground.setPixelColor(i,0,0,120);
  }

  // --- Medición y feedback ---
  float ang  = measureAngleDeg();
  float aabs = fabsf(ang);

  setRingProgress(aabs, targetDeg);

  if (aabs >= targetDeg) {
    if (!goalLatched) {
      goalLatched = true;
      motorPulse(pulseMs); // pulso háptico
    }
  } else {
    goalLatched = false;
  }

  // --- Motor watchdog ---
  if (motorOn && millis() >= motorOffAt) {
    digitalWrite(MOTOR_PIN, LOW);
    motorOn = false;
  }

  // --- Reporte BLE periódico ---
  if (Bluefruit.connected() && millis() - lastTx > reportMs) {
    char line[24];
    snprintf(line, sizeof(line), "ANGLE %.1f\n", ang);
    bleuart.write((uint8_t*)line, strlen(line));
    lastTx = millis();
  }

  // --- Comandos BLE entrantes ---
  readBleCommands();

  // pequeño respiro
  delay(10);
}
